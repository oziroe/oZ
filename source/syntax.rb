#!/usr/bin/env ruby
#
# source/syntax.rb
# Since there are so much similarity on each syntax node, and there is no
# good syntax tree generator tool found, so it may be a good idea to write
# a utility to generate all the syntax nodes' source file from yacc's rule.
#
# Created by oziroe on July 25, 2017.
#
require "Date"
require_relative "syntax/string"
require_relative "syntax/exttype"
require_relative "syntax/create"

rules_map = File.read(ARGV[1]).rules_map

if ARGV[0] == 'names'
    puts rules_map.keys
    exit 0
end

rules_type = Hash.new
rules_map.keys.each do |name|
    rules_type[name] = name.split('_').collect(&:capitalize).join
end

output_folder, extend_folder = ARGV[2], ARGV[3]
rules_map.each do |name, rules|
    header_tag = "OZ_SOURCE_#{output_folder.upcase}_#{name.upcase}_H"
    included_terms = rules.map{ |rule_map| rule_map[:rule] }.flatten.uniq.
        select{ |term| rules_map.include?(term) and term != name }
    include_extension = File.exist?(
        File.join(extend_folder, "#{name}.h")) ?
        "#include \"../#{extend_folder}/#{name}.h\"" : ""
    type_names = rules.map { |rule| rule[:type].upcase }
    union_values = rules.map do |rule|
        value_name = "#{rule[:type]}_value"
        terms = rule[:rule].reject{ |term| term.start_with?("'") }
        if terms.count > 1
            inner = terms.map do |t|
                t.declaration(rules_type, ADDITIONAL_TYPES, style=:struct_colon)
            end.reject(&:empty?).join("\n")
            "struct {\n#{inner.indent(1)}\n} #{rule[:type]}_value;"
        elsif terms.count == 1
            terms[0].declaration(rules_type, ADDITIONAL_TYPES,
                style=:struct_value)
        else
            ""
        end.chomp
    end.join("\n").strip
    union_empty_comment = lambda do |indent_level|
        union_values.strip.empty? ?
        "// Nothing here.".indent(indent_level) : ""
    end

    file_name = File.join(output_folder, "#{name}.h")
    File.open(file_name, 'w') do |file|
        file <<
<<-EOF
//
// source/#{output_folder}/#{name}.h
// Auto-generated header file for syntax tree node.
//
// Generated by `source/syntax.rb` on #{Date.today.strftime("%b %-d, %Y")}.
//

#ifndef #{header_tag}
#define #{header_tag}

#include "forward.h"
#{included_terms.map{ |term| "#include \"#{term}.h\""}.join("\n")}
#{include_extension}
//typedef struct _#{rules_type[name]} *#{rules_type[name]};

#{rules.map { |rule| syntax_tree_create(name, rule, rules_type, ADDITIONAL_TYPES, impl=false) }.join("\n")}

#endif
EOF
    end

    file_name = File.join(output_folder, "#{name}.c")
    File.open(file_name, 'w') do |file|
        file <<
<<-EOF
//
// source/#{output_folder}/#{name}.c
//
// Generated by `source/syntax.rb` on #{Date.today.strftime("%b %-d, %Y")}.
//

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "#{name}.h"

struct _#{rules_type[name]} {
    enum { #{type_names.join(', ')} } type;
    union {
#{union_values.indent(2)}#{union_empty_comment.call(indent_level=2)}
    } value;
};

EOF
    end
end

file_name = ARGV[4]
File.open(file_name, 'w') do |file|
    file <<
<<-COMMENT_END
//
// source/#{file_name}.h
// Include all the auto-generated header files.
//
// Generated by `source/syntax.rb` on #{Date.today.strftime("%b %-d, %Y")}.
//
COMMENT_END
    header_tag = "OZ_SOURCE_#{file_name.gsub(/[^\w]/, '_').upcase}"
    file << "#ifndef #{header_tag}\n#define #{header_tag}\n\n"
    file << rules_map.keys.map do |name|
            "#include \"#{output_folder}/#{name}.h\""
        end.join("\n")
    file << "\n\n#endif"
end

file_name = File.join(output_folder, "forward.h")
File.open(file_name, 'w') do |file|
    file <<
<<-COMMENT_END
//
// source/#{output_folder}/forward.h
// Forward declarations.
//
// Generated by `source/syntax.rb` on #{Date.today.strftime("%b %-d, %Y")}.
//
COMMENT_END
    header_tag = "OZ_SOURCE_#{output_folder.upcase}_FORWARD_H"
    file << "#ifndef #{header_tag}\n#define #{header_tag}\n\n"
    file << rules_map.keys.map do |name|
        "typedef struct _#{rules_type[name]} *#{rules_type[name]};"
    end.join("\n")
    file << "\n\n#endif"
end
