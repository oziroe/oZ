#!/usr/bin/env ruby
#
# source/syntax.rb
# Since there are so much similarity on each syntax node, and there is no
# good syntax tree generator tool found, so it may be a good idea to write
# a utility to generate all the syntax nodes' source file from yacc's rule.
#
# Created by oziroe on July 25, 2017.
#
require "Date"

$yacc_text = File.read(ARGV[0])
$rule_text = $yacc_text[/.*%%([^%]*)%%.*/, 1]

def $rule_text.remove_code_blocks
    level = 0
    self.chars.map do |c|
        if c == '{'
            level += 1
            ''
        elsif c == '}'
            level -= 1
            ''
        else
            level == 0 ? c : ''
        end
    end.join
end
$pure_rule = $rule_text.remove_code_blocks

$rules = $pure_rule.split(';').select{ |r| r.strip != '' }
$rules_map = Hash.new
$rules.each do |rule_text|
    splited = rule_text.split(':', 2)
    name, content = splited[0].strip, splited[1].strip
    rules = content.split('|').map(&:strip)
    $rules_map[name] = rules.map do |rule|
        rule_splited = rule.match(/\/\*(.*)\*\/(.*)/m)
        rule_name, rule_content = rule_splited[1].strip, rule_splited[2].strip
        {:type => rule_name, :rule => rule_content.split}
    end
end

$rules_type = Hash.new
$rules_map.keys.each do |name|
    $rules_type[name] = name.split('_').collect(&:capitalize).join
end
$additional_types = {
    'IDENTIFIER'    => 'char *',
    'INTEGER'       => 'int',
    'UNARY'         => 'char *',
    'OPERATOR'      => 'char *',
}

class String
    def indent(level)
        self.split("\n").map do |line|
            "    " * level + line
        end.join("\n")
    end

    def declaration()
        if $rules_type.include?(self)
            "#{$rules_type[self]} #{self}_value;"
        elsif $additional_types.include?(self)
            "#{$additional_types[self]} #{self.downcase}_value;"
        else
            ""
        end
    end
end

$output_folder, $extend_folder = ARGV[1], ARGV[2]
$rules_map.each do |name, rules|
    header_tag = "OZ_SOURCE_#{$output_folder.upcase}_#{name.upcase}_H"
    included_terms = rules.map{ |rule_map| rule_map[:rule] }.flatten.uniq.
        select{ |term| $rules_map.include?(term) and term != name }
    include_extension = File.exist?(
        File.join($extend_folder, "#{name}.h")) ?
        "#include \"../#{$extend_folder}/#{name}.h\"" : ""
    type_names = rules.map { |rule| rule[:type].upcase }
    union_values = rules.map do |rule|
        value_name = "#{rule[:type]}_value"
        terms = rule[:rule].reject{ |term| term.start_with?("'") }
        if terms.count > 1
            inner = terms.map(&:declaration).reject(&:empty?).join("\n")
            "struct {\n#{inner.indent(1)}\n} #{rule[:type]}_value;"
        elsif terms.count == 1
            terms[0].declaration
        else
            ""
        end.chomp
    end.join("\n").strip
    union_empty_comment = lambda do |indent_level|
        union_values.strip.empty? ?
        "// Nothing here.".indent(indent_level) : ""
    end

    file_name = File.join($output_folder, "#{name}.h")
    File.open(file_name, 'w') do |file|
        file <<
<<-EOF
//
// source/#{$output_folder}/#{name}.h
// Auto-generated header file for syntax tree node.
//
// Generated by `source/syntax.rb` on #{Date.today.strftime("%b %-d, %Y")}.
//

#ifndef #{header_tag}
#define #{header_tag}

#{included_terms.map{ |term| "#include \"#{term}.h\""}.join("\n")}
#{include_extension}
typedef struct _#{$rules_type[name]} *#{$rules_type[name]};

#endif
EOF
    end

    file_name = File.join($output_folder, "#{name}.c")
    File.open(file_name, 'w') do |file|
        file <<
<<-EOF
//
// source/#{$output_folder}/#{name}.c
//
// Generated by `source/syntax.rb` on #{Date.today.strftime("%b %-d, %Y")}.
//

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "#{name}.h"

struct _#{$rules_type[name]} {
    enum { #{type_names.join(', ')} } type;
    union {
#{union_values.indent(2)}#{union_empty_comment.call(indent_level=2)}
    } value;
};

EOF
    end
end

$file_name = ARGV[3]
File.open($file_name, 'w') do |file|
    file <<
<<-COMMENT_END
//
// source/#{$file_name}.h
// Include all the auto-generated header files.
//
// Generated by `source/syntax.rb` on #{Date.today.strftime("%b %-d, %Y")}.
//
COMMENT_END
    header_tag = "OZ_SOURCE_#{$file_name.gsub(/[^\w]/, '_').upcase}"
    file << "#ifndef #{header_tag}\n#define #{header_tag}\n\n"
    file << $rules_map.keys.map do |name|
            "#include \"#{$output_folder}/#{name}.h\""
        end.join("\n")
    file << "\n\n#endif"

end
